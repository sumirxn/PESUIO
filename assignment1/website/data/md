Title: Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models

URL Source: https://arxiv.org/html/2410.07176v1

Markdown Content:
\\pdftrailerid

redacted \\correspondingauthorfwang598@usc.edu, soarik@google.com

Xingchen Wan Google Cloud AI Research Ruoxi Sun Google Cloud AI Research Jiefeng Chen Google Cloud AI Research Sercan Ö. Arık Google Cloud AI Research

###### Abstract

Retrieval-Augmented Generation (RAG), while effective in integrating external knowledge to address the limitations of large language models (LLMs), can be undermined by imperfect retrieval, which may introduce irrelevant, misleading, or even malicious information. Despite its importance, previous studies have rarely explored the behavior of RAG through joint analysis on how errors from imperfect retrieval attribute and propagate, and how potential conflicts arise between the LLMs’ internal knowledge and external sources. We find that imperfect retrieval augmentation might be inevitable and quite harmful, through controlled analysis under realistic conditions. We identify the knowledge conflicts between LLM-internal and external knowledge from retrieval as a bottleneck to overcome in the post-retrieval stage of RAG. To render LLMs resilient to imperfect retrieval, we propose Astute RAG, a novel RAG approach that adaptively elicits essential information from LLMs’ internal knowledge, iteratively consolidates internal and external knowledge with source-awareness, and finalizes the answer according to information reliability. Our experiments using Gemini and Claude demonstrate that Astute RAG significantly outperforms previous robustness-enhanced RAG methods. Notably, Astute RAG is the only approach that matches or exceeds the performance of LLMs without RAG under worst-case scenarios. Further analysis reveals that Astute RAG effectively resolves knowledge conflicts, improving the reliability and trustworthiness of RAG systems.

1 Introduction
--------------

Retrieval augmented generation (RAG) has become the standard approach for large language models (LLMs) to tackle knowledge-intensive tasks (Guu et al., [2020](https://arxiv.org/html/2410.07176v1#bib.bib11); Lewis et al., [2020](https://arxiv.org/html/2410.07176v1#bib.bib17)). Prior works mainly leverage RAG to address the inherent knowledge limitations of LLMs, effectively integrating missing information and grounding to reliable sources. However, recent research has highlighted a significant drawback that RAG might rely on imperfect retrieval results, including irrelevant, misleading, or even malicious information, which eventually leads to inaccurate LLM responses (Chen et al., [2024a](https://arxiv.org/html/2410.07176v1#bib.bib5); Xiang et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib32); Zou et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib46)). For example, when asked about the practice of eating rocks, LLMs might cite misleading information, such as a satirical news source claiming that one should consume at least one rock per day.111[https://www.bbc.com/news/articles/cd11gzejgz4o](https://www.bbc.com/news/articles/cd11gzejgz4o). The occurrence of imperfect retrieval augmentation is inevitable, driven by factors such as corpus quality limitations (Shao et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib22)), the reliability of retrievers (Dai et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib8)), and the complexity of the queries (Su et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib23)). This poses a significant challenge to the trustworthiness of RAG.

While there have been independent analyses of information retrieval and RAG in the context of LLMs (Su et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib23); Mallen et al., [2023](https://arxiv.org/html/2410.07176v1#bib.bib20)), previous studies have rarely connected the behaviors of retrieval and subsequent generation, particularly regarding the propagation of information retrieval errors, which may lead to knowledge conflicts (Longpre et al., [2021](https://arxiv.org/html/2410.07176v1#bib.bib18); Wang et al., [2023a](https://arxiv.org/html/2410.07176v1#bib.bib27); Xu et al., [2024b](https://arxiv.org/html/2410.07176v1#bib.bib36)) between LLMs and context. To this end, we conduct comprehensive analyses on the occurrence of imperfect retrieval augmentation and its impact on LLM behavior under realistic conditions (Section [2](https://arxiv.org/html/2410.07176v1#S2 "2 Imperfect Retrieval: The Pitfall of RAG ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")). We conduct controlled experiments on a diverse range of general, domain-specific, and long-tail questions from NQ (Kwiatkowski et al., [2019](https://arxiv.org/html/2410.07176v1#bib.bib16)), TriviaQA (Joshi et al., [2017](https://arxiv.org/html/2410.07176v1#bib.bib15)), BioASQ (Tsatsaronis et al., [2015](https://arxiv.org/html/2410.07176v1#bib.bib26)), and PopQA (Mallen et al., [2023](https://arxiv.org/html/2410.07176v1#bib.bib20)). We observe that imperfect retrieval augmentation is widespread even with adept real-world search engine (such as Google Search with Web as corpus) – roughly 70% retrieved passages do not directly contain true answers, leading to the impeded performance of LLM with RAG augmentation.222Note that some passages may contain information indirectly relevant to the answer, but may unintentionally mislead or distract LLMs.

These findings underscore the potential severity of the imperfect retrieval issue in real-world RAG and highlight the widespread existence of knowledge conflicts as the bottleneck to overcome it (Figure [1](https://arxiv.org/html/2410.07176v1#S1.F1 "Figure 1 ‣ 1 Introduction ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")). Recent studies demonstrate that LLM-internal and external knowledge offer distinct advantages, but LLMs often struggle to consolidate conflicting information reliably, failing to respond based on collective knowledge (Mallen et al., [2023](https://arxiv.org/html/2410.07176v1#bib.bib20); Tan et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib24); Xie et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib33); Jin et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib14)). This raises the following research question: Is there an effective method to combine internal (from LLMs’ pretrained weights) and external (from specific corpora or knowledge bases) knowledge for more reliable RAG? Previous work has widely explored using external knowledge to enhance LLMs through RAG. We seek to further leverage LLMs’ internal knowledge to recover from RAG failures

![Image 1: Refer to caption](https://arxiv.org/html/2410.07176v1/extracted/5914248/figure/problem_3.png)

Figure 1: Knowledge conflicts between the LLMs’ internal knowledge and retrieved knowledge from external sources. We report the overall results with Claude under the setting in Section [4.1](https://arxiv.org/html/2410.07176v1#S4.SS1 "4.1 Experimental Settings ‣ 4 Experiments ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models").

Motivated by these important real-world challenges, we propose Astute RAG (Section [3](https://arxiv.org/html/2410.07176v1#S3 "3 Astute RAG: Overcoming the Pitfall ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")), a novel RAG approach designed to be resilient to imperfect retrieval augmentation, while preserving RAG grounding effect when RAG is reliable. To this end, Astute RAG needs effectively differentiate the reliability of the LLM’s intrinsic knowledge and the external information retrieved in RAG, utilizing each only when trustworthy and ensuring proper integration. Specifically, Astute RAG initially elicits information from LLMs’ internal knowledge to explicitly complement the passages retrieved from external sources. Then, Astute RAG conducts source-aware knowledge consolidation of information from various internal and external sources. The desiderata is combining consistent information, identifying conflicting information, and filtering out irrelevant information. Finally, Astute RAG proposes answers based on each group of consistent passages and compares the answers from different passage groups to determine the final answer. Our experiments involving Gemini and Claude333[https://www.anthropic.com/claude](https://www.anthropic.com/claude) on various datasets (Section [4](https://arxiv.org/html/2410.07176v1#S4 "4 Experiments ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")) demonstrate the superior performance of Astute RAG compared to previous RAG approaches designed to be robust against retrieval corruptions. Moreover, Astute RAG consistently outperforms baselines across different retrieval quality levels. Notably, Astute RAG is the only RAG method that achieves performance comparable to or even surpassing conventional use of LLMs under the worst-case scenario where all retrieved passages are unhelpful. Further analysis reveals the effectiveness of Astute RAG in resolving knowledge conflicts between internal and external knowledge.

To conclude, our core contributions are threefold. First, we analyze RAG under realistic conditions, identifying imperfect retrieval augmentation as a significant contributor to RAG failures and pinpointing knowledge conflicts as the primary bottleneck in overcoming it. Second, we propose Astute RAG, which explicitly addresses conflicts between LLM-internal and external knowledge, thereby recovering from RAG failures. Third, experiments with various LLMs and datasets demonstrate the effectiveness of Astute RAG, even in the most challenging scenarios.

2 Imperfect Retrieval: The Pitfall of RAG
-----------------------------------------

![Image 2: Refer to caption](https://arxiv.org/html/2410.07176v1/extracted/5914248/figure/retrieval.png)

Figure 2: Imperfect retrieval (samples with low retrieval precision) is prevalent in real-world RAG.

To better showcase the common real-world challenges and to make better motivate for improved methodological designs, we evaluate retrieval quality, end-to-end RAG performance, and knowledge conflicts on a controlled set of data. The selected data encompass a diverse range of general, domain-specific, and long-tail questions from NQ (Kwiatkowski et al., [2019](https://arxiv.org/html/2410.07176v1#bib.bib16)), TriviaQA (Joshi et al., [2017](https://arxiv.org/html/2410.07176v1#bib.bib15)), BioASQ (Tsatsaronis et al., [2015](https://arxiv.org/html/2410.07176v1#bib.bib26)), and PopQA (Mallen et al., [2023](https://arxiv.org/html/2410.07176v1#bib.bib20)). Our analysis is based on realistic retrieval results with Google Search444[https://developers.google.com/custom-search/v1/overview](https://developers.google.com/custom-search/v1/overview) as the retriever and the Web as the corpus. This setting allows us to analyze the severity of imperfect retrieval in real-world RAG. Overall, we sample 1K short-form QA instances from these datasets, and pair each instance with 10 retrieved passages.

Imperfect retrieval is common. We examine the occurrence of correct answers in retrieved passages as an approximation of retrieval quality. Since we mainly focus on short-form QA which provides most variants of the correct answer for each question, the approximation through string matching can give us a rouge intuition of how precise the retrieval result is. Specifically, we define the retrieval precision as the ratio of passages containing the correct answer for each instance:

<table id="S2.Ex1"><tbody><tr><td></td><td><math alttext="\text{Retrieval Precision}=\frac{\text{\{number of retrieved passages %
containing correct answer\}}}{\text{\{number of total retrieved passages\}}}" display="block" id="S2.Ex1.m1.1"><semantics id="S2.Ex1.m1.1a"><mrow id="S2.Ex1.m1.1.1" xref="S2.Ex1.m1.1.1.cmml"><mtext id="S2.Ex1.m1.1.1.2" xref="S2.Ex1.m1.1.1.2a.cmml">Retrieval Precision</mtext><mo id="S2.Ex1.m1.1.1.1" xref="S2.Ex1.m1.1.1.1.cmml">=</mo><mfrac id="S2.Ex1.m1.1.1.3" xref="S2.Ex1.m1.1.1.3.cmml"><mtext id="S2.Ex1.m1.1.1.3.2" xref="S2.Ex1.m1.1.1.3.2a.cmml">{number of retrieved passages containing correct answer}</mtext><mtext id="S2.Ex1.m1.1.1.3.3" xref="S2.Ex1.m1.1.1.3.3a.cmml">{number of total retrieved passages}</mtext></mfrac></mrow><annotation-xml encoding="MathML-Content" id="S2.Ex1.m1.1b"><apply id="S2.Ex1.m1.1.1.cmml" xref="S2.Ex1.m1.1.1"><eq id="S2.Ex1.m1.1.1.1.cmml" xref="S2.Ex1.m1.1.1.1"></eq><ci id="S2.Ex1.m1.1.1.2a.cmml" xref="S2.Ex1.m1.1.1.2"><mtext id="S2.Ex1.m1.1.1.2.cmml" xref="S2.Ex1.m1.1.1.2">Retrieval Precision</mtext></ci><apply id="S2.Ex1.m1.1.1.3.cmml" xref="S2.Ex1.m1.1.1.3"><divide id="S2.Ex1.m1.1.1.3.1.cmml" xref="S2.Ex1.m1.1.1.3"></divide><ci id="S2.Ex1.m1.1.1.3.2a.cmml" xref="S2.Ex1.m1.1.1.3.2"><mtext id="S2.Ex1.m1.1.1.3.2.cmml" xref="S2.Ex1.m1.1.1.3.2">{number of retrieved passages containing correct answer}</mtext></ci><ci id="S2.Ex1.m1.1.1.3.3a.cmml" xref="S2.Ex1.m1.1.1.3.3"><mtext id="S2.Ex1.m1.1.1.3.3.cmml" xref="S2.Ex1.m1.1.1.3.3">{number of total retrieved passages}</mtext></ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.Ex1.m1.1c">\text{Retrieval Precision}=\frac{\text{\{number of retrieved passages % containing correct answer\}}}{\text{\{number of total retrieved passages\}}}</annotation><annotation encoding="application/x-llamapun" id="S2.Ex1.m1.1d">Retrieval Precision = divide start_ARG {number of retrieved passages containing correct answer} end_ARG start_ARG {number of total retrieved passages} end_ARG</annotation></semantics></math></td><td></td></tr></tbody></table>

As shown in Figure [2](https://arxiv.org/html/2410.07176v1#S2.F2 "Figure 2 ‣ 2 Imperfect Retrieval: The Pitfall of RAG ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models"), although instances from different datasets exhibit different data distributions, imperfect retrieval is prevalent. Specifically, ∼similar-to\\sim∼20% of the overall data have no mentions of the correct answer within any retrieved passage, including 34% on NQ, 18% on TriviaQA, 24% on BioASQ, and 50% on PopQA. This finding also aligns with previous observation on information retrieval (Thakur et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib25)), that highlights that the number of positive passages can be very limited.

Imperfect retrieval leads to RAG failures. We further analyze the relation between retrieval quality and RAG performance. We compare the performance of Claude 3.5 Sonnet, with and without RAG and report the results by retrieval precision in Figure [4](https://arxiv.org/html/2410.07176v1#S4.F4 "Figure 4 ‣ 4.3 Analyses ‣ 4 Experiments ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models"). In general, RAG is helpful when the retrieval precision is not lower than 20%. When the retrieval precision is close to 0, the model with RAG performs much worse than without RAG, indicating that imperfect retrieval augmentation can be the cause of RAG failures. This finding aligns with the previous observation from Yu et al. ([2024](https://arxiv.org/html/2410.07176v1#bib.bib42)) that adding more retrieved passages does not necessarily lead to better performance, as the additional passages might reduce the retrieval precision.

Knowledge conflicts widely exist in RAG failures. We provide an in-depth analyses of knowledge conflicts between LLMs’ internal knowledge and retrieved passages from external sources. With Claude 3.5 Sonnet as the LLM, Figure [1](https://arxiv.org/html/2410.07176v1#S1.F1 "Figure 1 ‣ 1 Introduction ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models") shows that 19.2% of the overall data exhibit knowledge conflicts, where either the answer with or without RAG is correct. Among the conflicting cases, the internal knowledge is correct on 47.4% of them, while the external knowledge is correct on the remaining 52.6%. These results emphasize the importance of effectively combining the internal and external knowledge to overcome the inherent limitation of relying solely on either source. However, previous work (Tan et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib24); Xie et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib33); Jin et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib14)) show that LLMs might respond based on misleading information rather than comprehensive understanding of the conflicting knowledge in this context.

3 Astute RAG: Overcoming the Pitfall
------------------------------------

![Image 3: Refer to caption](https://arxiv.org/html/2410.07176v1/extracted/5914248/figure/method_2.png)

Figure 3: Overview of the proposed Astute RAG framework. Astute RAG is designed to better combine the information from the external sources (e.g. web, domain-specific corpora, knowledge bases) and internal knowledge of the LLMs by employing a consolidation mechanism to address the information conflicts, which eventually leads to better quality generated outputs.

We begin with formulating the problem of imperfect retrieval in RAG (Section [3.1](https://arxiv.org/html/2410.07176v1#S3.SS1 "3.1 Problem Formulation ‣ 3 Astute RAG: Overcoming the Pitfall ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")). We then provide an overview of Astute RAG, designed to overcome this problem (Section [3.2](https://arxiv.org/html/2410.07176v1#S3.SS2 "3.2 Overview of the Framework ‣ 3 Astute RAG: Overcoming the Pitfall ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")). Subsequently, we delve into the three major steps of Astute RAG, including adaptive generation of internal knowledge (Section [3.3](https://arxiv.org/html/2410.07176v1#S3.SS3 "3.3 Adaptive Generation of Internal Knowledge ‣ 3 Astute RAG: Overcoming the Pitfall ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")), source-aware knowledge consolidation (Section [3.4](https://arxiv.org/html/2410.07176v1#S3.SS4 "3.4 Iterative Source-aware Knowledge Consolidation ‣ 3 Astute RAG: Overcoming the Pitfall ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")), and answer finalization (Section [3.5](https://arxiv.org/html/2410.07176v1#S3.SS5 "3.5 Answer Finalization ‣ 3 Astute RAG: Overcoming the Pitfall ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")).

### 3.1 Problem Formulation

Our objective is to mitigate the effects of imperfect retrieval augmentation, resolve knowledge conflicts between the LLM’s internal knowledge and external sources (such as custom/public corpora and knowledge bases), and ultimately produce more accurate and reliable responses from LLMs.

Given a set of retrieved passages from external sources E\=\[e1,…,en\]𝐸subscript𝑒1…subscript𝑒𝑛E=\[e\_{1},\\ldots,e\_{n}\]italic\_E = \[ italic\_e start\_POSTSUBSCRIPT 1 end\_POSTSUBSCRIPT , … , italic\_e start\_POSTSUBSCRIPT italic\_n end\_POSTSUBSCRIPT \], a pre-trained LLM ℳℳ\\mathcal{M}caligraphic\_M (accessible through prediction-only APIs, encompassing commercial black-box ones), and a query q𝑞qitalic\_q, the task is to generate the corresponding correct answer a∗superscript𝑎a^{\*}italic\_a start\_POSTSUPERSCRIPT ∗ end\_POSTSUPERSCRIPT. Notably, this setting is orthogonal to prior work on improving the retriever, training LLMs, or conducting adaptive retrieval, which are mainly preliminary steps.

### 3.2 Overview of the Framework

Astute RAG is designed to better leverage collective knowledge from both internal knowledge of LLMs and external corpus, for more reliable responses. As shown in Figure [3](https://arxiv.org/html/2410.07176v1#S3.F3 "Figure 3 ‣ 3 Astute RAG: Overcoming the Pitfall ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models") and Algorithm [1](https://arxiv.org/html/2410.07176v1#alg1 "Algorithm 1 ‣ 3.2 Overview of the Framework ‣ 3 Astute RAG: Overcoming the Pitfall ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models"), Astute RAG starts from acquiring the most accurate, relevant, and thorough passage set from the LLMs’ internal knowledge. Then, internal and external knowledge are consolidated in an iterative way, by comparing the generated and retrieved passages. Finally, the reliability of conflicting information is compared and the final output is generated according to the most reliable knowledge.

Algorithm 1 Astute RAG

1:Query

q𝑞qitalic\_q, Retrieved Passages

E\=\[e1,…,en\]𝐸subscript𝑒1…subscript𝑒𝑛E=\[e\_{1},\\ldots,e\_{n}\]italic\_E = \[ italic\_e start\_POSTSUBSCRIPT 1 end\_POSTSUBSCRIPT , … , italic\_e start\_POSTSUBSCRIPT italic\_n end\_POSTSUBSCRIPT \], Large Language Model

ℳℳ\\mathcal{M}caligraphic\_M, Number of Iteration

t𝑡titalic\_t, Max Number of Generated Passages

m^^𝑚\\hat{m}over^ start\_ARG italic\_m end\_ARG, Prompt Templates

pg⁢e⁢n,pc⁢o⁢n,pa⁢n⁢ssubscript𝑝𝑔𝑒𝑛subscript𝑝𝑐𝑜𝑛subscript𝑝𝑎𝑛𝑠p\_{gen},p\_{con},p\_{ans}italic\_p start\_POSTSUBSCRIPT italic\_g italic\_e italic\_n end\_POSTSUBSCRIPT , italic\_p start\_POSTSUBSCRIPT italic\_c italic\_o italic\_n end\_POSTSUBSCRIPT , italic\_p start\_POSTSUBSCRIPT italic\_a italic\_n italic\_s end\_POSTSUBSCRIPT

2:Adaptively generate passages:

I←ℳ⁢(pg⁢e⁢n,q,m^)←𝐼ℳsubscript𝑝𝑔𝑒𝑛𝑞^𝑚I\\leftarrow\\mathcal{M}(p\_{gen},q,\\hat{m})italic\_I ← caligraphic\_M ( italic\_p start\_POSTSUBSCRIPT italic\_g italic\_e italic\_n end\_POSTSUBSCRIPT , italic\_q , over^ start\_ARG italic\_m end\_ARG )▷▷\\triangleright▷ Section [3.3](https://arxiv.org/html/2410.07176v1#S3.SS3 "3.3 Adaptive Generation of Internal Knowledge ‣ 3 Astute RAG: Overcoming the Pitfall ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")

3:Combine internal and external passages:

D0←E⊕I←subscript𝐷0direct-sum𝐸𝐼D\_{0}\\leftarrow E\\oplus Iitalic\_D start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT ← italic\_E ⊕ italic\_I

4:Assign passage sources:

S0←\[𝟙{d∈E}⁢for⁢d⁢in⁢D0\]←subscript𝑆0delimited-\[\]subscript1𝑑𝐸for𝑑insubscript𝐷0S\_{0}\\leftarrow\[\\mathbbm{1}\_{\\{d\\in E\\}}\\text{for}\\ d\\ \\text{in}\\ D\_{0}\]italic\_S start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT ← \[ blackboard\_1 start\_POSTSUBSCRIPT { italic\_d ∈ italic\_E } end\_POSTSUBSCRIPT for italic\_d in italic\_D start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT \]

5:if

t\>1𝑡1t\>1italic\_t \> 1 then

6:     for

j\=1,…,t−1𝑗1…𝑡1j=1,\\ldots,t-1italic\_j = 1 , … , italic\_t - 1 do ▷▷\\triangleright▷ Section [3.4](https://arxiv.org/html/2410.07176v1#S3.SS4 "3.4 Iterative Source-aware Knowledge Consolidation ‣ 3 Astute RAG: Overcoming the Pitfall ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")

7:         Consolidate knowledge:

⟨Dj+1,Sj+1⟩←ℳ⁢(pc⁢o⁢n,q,⟨D0,S0⟩,⟨Dj,Sj⟩)←subscript𝐷𝑗1subscript𝑆𝑗1ℳsubscript𝑝𝑐𝑜𝑛𝑞subscript𝐷0subscript𝑆0subscript𝐷𝑗subscript𝑆𝑗\\langle D\_{j+1},S\_{j+1}\\rangle\\leftarrow\\mathcal{M}(p\_{con},q,\\langle D\_{0},S\_% {0}\\rangle,\\langle D\_{j},S\_{j}\\rangle)⟨ italic\_D start\_POSTSUBSCRIPT italic\_j + 1 end\_POSTSUBSCRIPT , italic\_S start\_POSTSUBSCRIPT italic\_j + 1 end\_POSTSUBSCRIPT ⟩ ← caligraphic\_M ( italic\_p start\_POSTSUBSCRIPT italic\_c italic\_o italic\_n end\_POSTSUBSCRIPT , italic\_q , ⟨ italic\_D start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT , italic\_S start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT ⟩ , ⟨ italic\_D start\_POSTSUBSCRIPT italic\_j end\_POSTSUBSCRIPT , italic\_S start\_POSTSUBSCRIPT italic\_j end\_POSTSUBSCRIPT ⟩ )

8:     end for

9:     Finally consolidate and answer:

a←ℳ⁢(pa⁢n⁢s,q,⟨D0,S0⟩,⟨Dt−1,St−1⟩)←𝑎ℳsubscript𝑝𝑎𝑛𝑠𝑞subscript𝐷0subscript𝑆0subscript𝐷𝑡1subscript𝑆𝑡1a\\leftarrow\\mathcal{M}(p\_{ans},q,\\langle D\_{0},S\_{0}\\rangle,\\langle D\_{t-1},S\_% {t-1}\\rangle)italic\_a ← caligraphic\_M ( italic\_p start\_POSTSUBSCRIPT italic\_a italic\_n italic\_s end\_POSTSUBSCRIPT , italic\_q , ⟨ italic\_D start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT , italic\_S start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT ⟩ , ⟨ italic\_D start\_POSTSUBSCRIPT italic\_t - 1 end\_POSTSUBSCRIPT , italic\_S start\_POSTSUBSCRIPT italic\_t - 1 end\_POSTSUBSCRIPT ⟩ )▷▷\\triangleright▷ Section [3.5](https://arxiv.org/html/2410.07176v1#S3.SS5 "3.5 Answer Finalization ‣ 3 Astute RAG: Overcoming the Pitfall ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")

10:else

11:     Consolidate knowledge and finalize the answer:

a←ℳ⁢(pa⁢n⁢s,q,⟨D0,S0⟩)←𝑎ℳsubscript𝑝𝑎𝑛𝑠𝑞subscript𝐷0subscript𝑆0a\\leftarrow\\mathcal{M}(p\_{ans},q,\\langle D\_{0},S\_{0}\\rangle)italic\_a ← caligraphic\_M ( italic\_p start\_POSTSUBSCRIPT italic\_a italic\_n italic\_s end\_POSTSUBSCRIPT , italic\_q , ⟨ italic\_D start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT , italic\_S start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT ⟩ )

12:end if

13:return

a𝑎aitalic\_a

### 3.3 Adaptive Generation of Internal Knowledge

In the first step, we elicit internal knowledge from LLMs. This LLM-internal knowledge, reflecting the consensus from extensive pre-training and instruction-tuning data, can supplement any missing information from the limited set of retrieved passages and enable mutual confirmation between LLM-internal and external knowledge. This is especially valuable when the majority of retrieved passages might be irrelevant or misleading. Specifically, we prompt LLMs to generate passages based on the given question q𝑞qitalic\_q, following Yu et al. ([2023a](https://arxiv.org/html/2410.07176v1#bib.bib40)). While Yu et al. ([2023a](https://arxiv.org/html/2410.07176v1#bib.bib40)) primarily focused on generating diverse internal passages, we emphasize the importance of reliability and trustworthiness of generated passages. To achieve this goal, we enhance the original method with constitutional principles and adaptive generation.

Inspired by Constitutional AI (Bai et al., [2022](https://arxiv.org/html/2410.07176v1#bib.bib2)), we provide constitutional principles indicating the desired properties of internal passages in the prompt pg⁢e⁢nsubscript𝑝𝑔𝑒𝑛p\_{gen}italic\_p start\_POSTSUBSCRIPT italic\_g italic\_e italic\_n end\_POSTSUBSCRIPT (see Appendix [A](https://arxiv.org/html/2410.07176v1#A1 "Appendix A Prompt Template for Astute RAG ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models") for details) to guide their generation, emphasizing that the generated passages should be accurate, relevant, and hallucination-free. Moreover, we allow the LLM to perform adaptive generation of passages in its internal knowledge. The LLM can decide how many passages to generate by itself. Rather generating a fix number of passages, we request the LLM to generate at most m^^𝑚\\hat{m}over^ start\_ARG italic\_m end\_ARG passages, each covering distinct information, and to directly indicate if no more reliable information is available. This adaptive approach allows the LLM to generate fewer passages (or even no passages at all) when the useful information within internal knowledge is limited and more passages when there are multiple feasible answers in the internal knowledge. In this step, the LLM generates m≤m^𝑚^𝑚m\\leq\\hat{m}italic\_m ≤ over^ start\_ARG italic\_m end\_ARG passages based on its internal knowledge:

<table id="S3.Ex2"><tbody><tr><td></td><td><math alttext="I=[i_{1},\ldots i_{m}]=\mathcal{M}(p_{gen},q,\hat{m})." display="block" id="S3.Ex2.m1.3"><semantics id="S3.Ex2.m1.3a"><mrow id="S3.Ex2.m1.3.3.1" xref="S3.Ex2.m1.3.3.1.1.cmml"><mrow id="S3.Ex2.m1.3.3.1.1" xref="S3.Ex2.m1.3.3.1.1.cmml"><mi id="S3.Ex2.m1.3.3.1.1.5" xref="S3.Ex2.m1.3.3.1.1.5.cmml">I</mi><mo id="S3.Ex2.m1.3.3.1.1.6" xref="S3.Ex2.m1.3.3.1.1.6.cmml">=</mo><mrow id="S3.Ex2.m1.3.3.1.1.2.2" xref="S3.Ex2.m1.3.3.1.1.2.3.cmml"><mo id="S3.Ex2.m1.3.3.1.1.2.2.3" stretchy="false" xref="S3.Ex2.m1.3.3.1.1.2.3.cmml">[</mo><msub id="S3.Ex2.m1.3.3.1.1.1.1.1" xref="S3.Ex2.m1.3.3.1.1.1.1.1.cmml"><mi id="S3.Ex2.m1.3.3.1.1.1.1.1.2" xref="S3.Ex2.m1.3.3.1.1.1.1.1.2.cmml">i</mi><mn id="S3.Ex2.m1.3.3.1.1.1.1.1.3" xref="S3.Ex2.m1.3.3.1.1.1.1.1.3.cmml">1</mn></msub><mo id="S3.Ex2.m1.3.3.1.1.2.2.4" xref="S3.Ex2.m1.3.3.1.1.2.3.cmml">,</mo><mrow id="S3.Ex2.m1.3.3.1.1.2.2.2" xref="S3.Ex2.m1.3.3.1.1.2.2.2.cmml"><mi id="S3.Ex2.m1.3.3.1.1.2.2.2.2" mathvariant="normal" xref="S3.Ex2.m1.3.3.1.1.2.2.2.2.cmml">…</mi><mo id="S3.Ex2.m1.3.3.1.1.2.2.2.1" xref="S3.Ex2.m1.3.3.1.1.2.2.2.1.cmml">⁢</mo><msub id="S3.Ex2.m1.3.3.1.1.2.2.2.3" xref="S3.Ex2.m1.3.3.1.1.2.2.2.3.cmml"><mi id="S3.Ex2.m1.3.3.1.1.2.2.2.3.2" xref="S3.Ex2.m1.3.3.1.1.2.2.2.3.2.cmml">i</mi><mi id="S3.Ex2.m1.3.3.1.1.2.2.2.3.3" xref="S3.Ex2.m1.3.3.1.1.2.2.2.3.3.cmml">m</mi></msub></mrow><mo id="S3.Ex2.m1.3.3.1.1.2.2.5" stretchy="false" xref="S3.Ex2.m1.3.3.1.1.2.3.cmml">]</mo></mrow><mo id="S3.Ex2.m1.3.3.1.1.7" xref="S3.Ex2.m1.3.3.1.1.7.cmml">=</mo><mrow id="S3.Ex2.m1.3.3.1.1.3" xref="S3.Ex2.m1.3.3.1.1.3.cmml"><mi id="S3.Ex2.m1.3.3.1.1.3.3" xref="S3.Ex2.m1.3.3.1.1.3.3.cmml">ℳ</mi><mo id="S3.Ex2.m1.3.3.1.1.3.2" xref="S3.Ex2.m1.3.3.1.1.3.2.cmml">⁢</mo><mrow id="S3.Ex2.m1.3.3.1.1.3.1.1" xref="S3.Ex2.m1.3.3.1.1.3.1.2.cmml"><mo id="S3.Ex2.m1.3.3.1.1.3.1.1.2" stretchy="false" xref="S3.Ex2.m1.3.3.1.1.3.1.2.cmml">(</mo><msub id="S3.Ex2.m1.3.3.1.1.3.1.1.1" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.cmml"><mi id="S3.Ex2.m1.3.3.1.1.3.1.1.1.2" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.2.cmml">p</mi><mrow id="S3.Ex2.m1.3.3.1.1.3.1.1.1.3" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.cmml"><mi id="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.2" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.2.cmml">g</mi><mo id="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.1" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.1.cmml">⁢</mo><mi id="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.3" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.3.cmml">e</mi><mo id="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.1a" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.1.cmml">⁢</mo><mi id="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.4" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.4.cmml">n</mi></mrow></msub><mo id="S3.Ex2.m1.3.3.1.1.3.1.1.3" xref="S3.Ex2.m1.3.3.1.1.3.1.2.cmml">,</mo><mi id="S3.Ex2.m1.1.1" xref="S3.Ex2.m1.1.1.cmml">q</mi><mo id="S3.Ex2.m1.3.3.1.1.3.1.1.4" xref="S3.Ex2.m1.3.3.1.1.3.1.2.cmml">,</mo><mover accent="true" id="S3.Ex2.m1.2.2" xref="S3.Ex2.m1.2.2.cmml"><mi id="S3.Ex2.m1.2.2.2" xref="S3.Ex2.m1.2.2.2.cmml">m</mi><mo id="S3.Ex2.m1.2.2.1" xref="S3.Ex2.m1.2.2.1.cmml">^</mo></mover><mo id="S3.Ex2.m1.3.3.1.1.3.1.1.5" stretchy="false" xref="S3.Ex2.m1.3.3.1.1.3.1.2.cmml">)</mo></mrow></mrow></mrow><mo id="S3.Ex2.m1.3.3.1.2" lspace="0em" xref="S3.Ex2.m1.3.3.1.1.cmml">.</mo></mrow><annotation-xml encoding="MathML-Content" id="S3.Ex2.m1.3b"><apply id="S3.Ex2.m1.3.3.1.1.cmml" xref="S3.Ex2.m1.3.3.1"><and id="S3.Ex2.m1.3.3.1.1a.cmml" xref="S3.Ex2.m1.3.3.1"></and><apply id="S3.Ex2.m1.3.3.1.1b.cmml" xref="S3.Ex2.m1.3.3.1"><eq id="S3.Ex2.m1.3.3.1.1.6.cmml" xref="S3.Ex2.m1.3.3.1.1.6"></eq><ci id="S3.Ex2.m1.3.3.1.1.5.cmml" xref="S3.Ex2.m1.3.3.1.1.5">𝐼</ci><interval closure="closed" id="S3.Ex2.m1.3.3.1.1.2.3.cmml" xref="S3.Ex2.m1.3.3.1.1.2.2"><apply id="S3.Ex2.m1.3.3.1.1.1.1.1.cmml" xref="S3.Ex2.m1.3.3.1.1.1.1.1"><csymbol cd="ambiguous" id="S3.Ex2.m1.3.3.1.1.1.1.1.1.cmml" xref="S3.Ex2.m1.3.3.1.1.1.1.1">subscript</csymbol><ci id="S3.Ex2.m1.3.3.1.1.1.1.1.2.cmml" xref="S3.Ex2.m1.3.3.1.1.1.1.1.2">𝑖</ci><cn id="S3.Ex2.m1.3.3.1.1.1.1.1.3.cmml" type="integer" xref="S3.Ex2.m1.3.3.1.1.1.1.1.3">1</cn></apply><apply id="S3.Ex2.m1.3.3.1.1.2.2.2.cmml" xref="S3.Ex2.m1.3.3.1.1.2.2.2"><times id="S3.Ex2.m1.3.3.1.1.2.2.2.1.cmml" xref="S3.Ex2.m1.3.3.1.1.2.2.2.1"></times><ci id="S3.Ex2.m1.3.3.1.1.2.2.2.2.cmml" xref="S3.Ex2.m1.3.3.1.1.2.2.2.2">…</ci><apply id="S3.Ex2.m1.3.3.1.1.2.2.2.3.cmml" xref="S3.Ex2.m1.3.3.1.1.2.2.2.3"><csymbol cd="ambiguous" id="S3.Ex2.m1.3.3.1.1.2.2.2.3.1.cmml" xref="S3.Ex2.m1.3.3.1.1.2.2.2.3">subscript</csymbol><ci id="S3.Ex2.m1.3.3.1.1.2.2.2.3.2.cmml" xref="S3.Ex2.m1.3.3.1.1.2.2.2.3.2">𝑖</ci><ci id="S3.Ex2.m1.3.3.1.1.2.2.2.3.3.cmml" xref="S3.Ex2.m1.3.3.1.1.2.2.2.3.3">𝑚</ci></apply></apply></interval></apply><apply id="S3.Ex2.m1.3.3.1.1c.cmml" xref="S3.Ex2.m1.3.3.1"><eq id="S3.Ex2.m1.3.3.1.1.7.cmml" xref="S3.Ex2.m1.3.3.1.1.7"></eq><share href="https://arxiv.org/html/2410.07176v1#S3.Ex2.m1.3.3.1.1.2.cmml" id="S3.Ex2.m1.3.3.1.1d.cmml" xref="S3.Ex2.m1.3.3.1"></share><apply id="S3.Ex2.m1.3.3.1.1.3.cmml" xref="S3.Ex2.m1.3.3.1.1.3"><times id="S3.Ex2.m1.3.3.1.1.3.2.cmml" xref="S3.Ex2.m1.3.3.1.1.3.2"></times><ci id="S3.Ex2.m1.3.3.1.1.3.3.cmml" xref="S3.Ex2.m1.3.3.1.1.3.3">ℳ</ci><vector id="S3.Ex2.m1.3.3.1.1.3.1.2.cmml" xref="S3.Ex2.m1.3.3.1.1.3.1.1"><apply id="S3.Ex2.m1.3.3.1.1.3.1.1.1.cmml" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1"><csymbol cd="ambiguous" id="S3.Ex2.m1.3.3.1.1.3.1.1.1.1.cmml" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1">subscript</csymbol><ci id="S3.Ex2.m1.3.3.1.1.3.1.1.1.2.cmml" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.2">𝑝</ci><apply id="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.cmml" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.3"><times id="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.1.cmml" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.1"></times><ci id="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.2.cmml" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.2">𝑔</ci><ci id="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.3.cmml" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.3">𝑒</ci><ci id="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.4.cmml" xref="S3.Ex2.m1.3.3.1.1.3.1.1.1.3.4">𝑛</ci></apply></apply><ci id="S3.Ex2.m1.1.1.cmml" xref="S3.Ex2.m1.1.1">𝑞</ci><apply id="S3.Ex2.m1.2.2.cmml" xref="S3.Ex2.m1.2.2"><ci id="S3.Ex2.m1.2.2.1.cmml" xref="S3.Ex2.m1.2.2.1">^</ci><ci id="S3.Ex2.m1.2.2.2.cmml" xref="S3.Ex2.m1.2.2.2">𝑚</ci></apply></vector></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.Ex2.m1.3c">I=[i_{1},\ldots i_{m}]=\mathcal{M}(p_{gen},q,\hat{m}).</annotation><annotation encoding="application/x-llamapun" id="S3.Ex2.m1.3d">italic_I = [ italic_i start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , … italic_i start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT ] = caligraphic_M ( italic_p start_POSTSUBSCRIPT italic_g italic_e italic_n end_POSTSUBSCRIPT , italic_q , over^ start_ARG italic_m end_ARG ) .</annotation></semantics></math></td><td></td></tr></tbody></table>

### 3.4 Iterative Source-aware Knowledge Consolidation

In the second step, we employ the LLM to explicitly consolidate information from both passages generated from its internal knowledge and passages retrieved from external sources. Initially, we combine passages from both internal and external knowledge sources D0\=E⊕I.subscript𝐷0direct-sum𝐸𝐼D\_{0}=E\\oplus I.italic\_D start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT = italic\_E ⊕ italic\_I .

We additionally ensure source-awareness by providing the source of each passage to LLMs when consolidating knowledge. The source information (internal or external, such as a website) is helpful in assessing the reliability of passages. Here, we provide the passage source as S0\=\[𝟙{d∈E}⁢for⁢d⁢in⁢D0\].subscript𝑆0delimited-\[\]subscript1𝑑𝐸for𝑑insubscript𝐷0S\_{0}=\[\\mathbbm{1}\_{\\{d\\in E\\}}\\text{for}\\ d\\ \\text{in}\\ D\_{0}\].italic\_S start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT = \[ blackboard\_1 start\_POSTSUBSCRIPT { italic\_d ∈ italic\_E } end\_POSTSUBSCRIPT for italic\_d in italic\_D start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT \] .

To consolidate knowledge, we prompt the LLM (with pc⁢o⁢nsubscript𝑝𝑐𝑜𝑛p\_{con}italic\_p start\_POSTSUBSCRIPT italic\_c italic\_o italic\_n end\_POSTSUBSCRIPT in Appendix [A](https://arxiv.org/html/2410.07176v1#A1 "Appendix A Prompt Template for Astute RAG ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")) to identify consistent information across passages, detect conflicting information between each group of consistent passages, and filter out irrelevant information. This step would regroup the unreliable knowledge in input passages into fewer refined passages. The regrouped passages will also attribute their source to the corresponding one or more input passages

<table id="S3.Ex3"><tbody><tr><td></td><td><math alttext="\langle D_{j+1},S_{j+1}\rangle=\mathcal{M}(p_{con},q,\langle D_{0},S_{0}%
\rangle,\langle D_{j},S_{j}\rangle)." display="block" id="S3.Ex3.m1.2"><semantics id="S3.Ex3.m1.2a"><mrow id="S3.Ex3.m1.2.2.1" xref="S3.Ex3.m1.2.2.1.1.cmml"><mrow id="S3.Ex3.m1.2.2.1.1" xref="S3.Ex3.m1.2.2.1.1.cmml"><mrow id="S3.Ex3.m1.2.2.1.1.2.2" xref="S3.Ex3.m1.2.2.1.1.2.3.cmml"><mo id="S3.Ex3.m1.2.2.1.1.2.2.3" stretchy="false" xref="S3.Ex3.m1.2.2.1.1.2.3.cmml">⟨</mo><msub id="S3.Ex3.m1.2.2.1.1.1.1.1" xref="S3.Ex3.m1.2.2.1.1.1.1.1.cmml"><mi id="S3.Ex3.m1.2.2.1.1.1.1.1.2" xref="S3.Ex3.m1.2.2.1.1.1.1.1.2.cmml">D</mi><mrow id="S3.Ex3.m1.2.2.1.1.1.1.1.3" xref="S3.Ex3.m1.2.2.1.1.1.1.1.3.cmml"><mi id="S3.Ex3.m1.2.2.1.1.1.1.1.3.2" xref="S3.Ex3.m1.2.2.1.1.1.1.1.3.2.cmml">j</mi><mo id="S3.Ex3.m1.2.2.1.1.1.1.1.3.1" xref="S3.Ex3.m1.2.2.1.1.1.1.1.3.1.cmml">+</mo><mn id="S3.Ex3.m1.2.2.1.1.1.1.1.3.3" xref="S3.Ex3.m1.2.2.1.1.1.1.1.3.3.cmml">1</mn></mrow></msub><mo id="S3.Ex3.m1.2.2.1.1.2.2.4" xref="S3.Ex3.m1.2.2.1.1.2.3.cmml">,</mo><msub id="S3.Ex3.m1.2.2.1.1.2.2.2" xref="S3.Ex3.m1.2.2.1.1.2.2.2.cmml"><mi id="S3.Ex3.m1.2.2.1.1.2.2.2.2" xref="S3.Ex3.m1.2.2.1.1.2.2.2.2.cmml">S</mi><mrow id="S3.Ex3.m1.2.2.1.1.2.2.2.3" xref="S3.Ex3.m1.2.2.1.1.2.2.2.3.cmml"><mi id="S3.Ex3.m1.2.2.1.1.2.2.2.3.2" xref="S3.Ex3.m1.2.2.1.1.2.2.2.3.2.cmml">j</mi><mo id="S3.Ex3.m1.2.2.1.1.2.2.2.3.1" xref="S3.Ex3.m1.2.2.1.1.2.2.2.3.1.cmml">+</mo><mn id="S3.Ex3.m1.2.2.1.1.2.2.2.3.3" xref="S3.Ex3.m1.2.2.1.1.2.2.2.3.3.cmml">1</mn></mrow></msub><mo id="S3.Ex3.m1.2.2.1.1.2.2.5" stretchy="false" xref="S3.Ex3.m1.2.2.1.1.2.3.cmml">⟩</mo></mrow><mo id="S3.Ex3.m1.2.2.1.1.6" xref="S3.Ex3.m1.2.2.1.1.6.cmml">=</mo><mrow id="S3.Ex3.m1.2.2.1.1.5" xref="S3.Ex3.m1.2.2.1.1.5.cmml"><mi id="S3.Ex3.m1.2.2.1.1.5.5" xref="S3.Ex3.m1.2.2.1.1.5.5.cmml">ℳ</mi><mo id="S3.Ex3.m1.2.2.1.1.5.4" xref="S3.Ex3.m1.2.2.1.1.5.4.cmml">⁢</mo><mrow id="S3.Ex3.m1.2.2.1.1.5.3.3" xref="S3.Ex3.m1.2.2.1.1.5.3.4.cmml"><mo id="S3.Ex3.m1.2.2.1.1.5.3.3.4" stretchy="false" xref="S3.Ex3.m1.2.2.1.1.5.3.4.cmml">(</mo><msub id="S3.Ex3.m1.2.2.1.1.3.1.1.1" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.cmml"><mi id="S3.Ex3.m1.2.2.1.1.3.1.1.1.2" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.2.cmml">p</mi><mrow id="S3.Ex3.m1.2.2.1.1.3.1.1.1.3" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.cmml"><mi id="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.2" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.2.cmml">c</mi><mo id="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.1" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.1.cmml">⁢</mo><mi id="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.3" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.3.cmml">o</mi><mo id="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.1a" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.1.cmml">⁢</mo><mi id="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.4" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.4.cmml">n</mi></mrow></msub><mo id="S3.Ex3.m1.2.2.1.1.5.3.3.5" xref="S3.Ex3.m1.2.2.1.1.5.3.4.cmml">,</mo><mi id="S3.Ex3.m1.1.1" xref="S3.Ex3.m1.1.1.cmml">q</mi><mo id="S3.Ex3.m1.2.2.1.1.5.3.3.6" xref="S3.Ex3.m1.2.2.1.1.5.3.4.cmml">,</mo><mrow id="S3.Ex3.m1.2.2.1.1.4.2.2.2.2" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.3.cmml"><mo id="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.3" stretchy="false" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.3.cmml">⟨</mo><msub id="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1.cmml"><mi id="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1.2" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1.2.cmml">D</mi><mn id="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1.3" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1.3.cmml">0</mn></msub><mo id="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.4" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.3.cmml">,</mo><msub id="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2.cmml"><mi id="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2.2" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2.2.cmml">S</mi><mn id="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2.3" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2.3.cmml">0</mn></msub><mo id="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.5" stretchy="false" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.3.cmml">⟩</mo></mrow><mo id="S3.Ex3.m1.2.2.1.1.5.3.3.7" xref="S3.Ex3.m1.2.2.1.1.5.3.4.cmml">,</mo><mrow id="S3.Ex3.m1.2.2.1.1.5.3.3.3.2" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.3.cmml"><mo id="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.3" stretchy="false" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.3.cmml">⟨</mo><msub id="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1.cmml"><mi id="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1.2" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1.2.cmml">D</mi><mi id="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1.3" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1.3.cmml">j</mi></msub><mo id="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.4" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.3.cmml">,</mo><msub id="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2.cmml"><mi id="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2.2" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2.2.cmml">S</mi><mi id="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2.3" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2.3.cmml">j</mi></msub><mo id="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.5" stretchy="false" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.3.cmml">⟩</mo></mrow><mo id="S3.Ex3.m1.2.2.1.1.5.3.3.8" stretchy="false" xref="S3.Ex3.m1.2.2.1.1.5.3.4.cmml">)</mo></mrow></mrow></mrow><mo id="S3.Ex3.m1.2.2.1.2" lspace="0em" xref="S3.Ex3.m1.2.2.1.1.cmml">.</mo></mrow><annotation-xml encoding="MathML-Content" id="S3.Ex3.m1.2b"><apply id="S3.Ex3.m1.2.2.1.1.cmml" xref="S3.Ex3.m1.2.2.1"><eq id="S3.Ex3.m1.2.2.1.1.6.cmml" xref="S3.Ex3.m1.2.2.1.1.6"></eq><list id="S3.Ex3.m1.2.2.1.1.2.3.cmml" xref="S3.Ex3.m1.2.2.1.1.2.2"><apply id="S3.Ex3.m1.2.2.1.1.1.1.1.cmml" xref="S3.Ex3.m1.2.2.1.1.1.1.1"><csymbol cd="ambiguous" id="S3.Ex3.m1.2.2.1.1.1.1.1.1.cmml" xref="S3.Ex3.m1.2.2.1.1.1.1.1">subscript</csymbol><ci id="S3.Ex3.m1.2.2.1.1.1.1.1.2.cmml" xref="S3.Ex3.m1.2.2.1.1.1.1.1.2">𝐷</ci><apply id="S3.Ex3.m1.2.2.1.1.1.1.1.3.cmml" xref="S3.Ex3.m1.2.2.1.1.1.1.1.3"><plus id="S3.Ex3.m1.2.2.1.1.1.1.1.3.1.cmml" xref="S3.Ex3.m1.2.2.1.1.1.1.1.3.1"></plus><ci id="S3.Ex3.m1.2.2.1.1.1.1.1.3.2.cmml" xref="S3.Ex3.m1.2.2.1.1.1.1.1.3.2">𝑗</ci><cn id="S3.Ex3.m1.2.2.1.1.1.1.1.3.3.cmml" type="integer" xref="S3.Ex3.m1.2.2.1.1.1.1.1.3.3">1</cn></apply></apply><apply id="S3.Ex3.m1.2.2.1.1.2.2.2.cmml" xref="S3.Ex3.m1.2.2.1.1.2.2.2"><csymbol cd="ambiguous" id="S3.Ex3.m1.2.2.1.1.2.2.2.1.cmml" xref="S3.Ex3.m1.2.2.1.1.2.2.2">subscript</csymbol><ci id="S3.Ex3.m1.2.2.1.1.2.2.2.2.cmml" xref="S3.Ex3.m1.2.2.1.1.2.2.2.2">𝑆</ci><apply id="S3.Ex3.m1.2.2.1.1.2.2.2.3.cmml" xref="S3.Ex3.m1.2.2.1.1.2.2.2.3"><plus id="S3.Ex3.m1.2.2.1.1.2.2.2.3.1.cmml" xref="S3.Ex3.m1.2.2.1.1.2.2.2.3.1"></plus><ci id="S3.Ex3.m1.2.2.1.1.2.2.2.3.2.cmml" xref="S3.Ex3.m1.2.2.1.1.2.2.2.3.2">𝑗</ci><cn id="S3.Ex3.m1.2.2.1.1.2.2.2.3.3.cmml" type="integer" xref="S3.Ex3.m1.2.2.1.1.2.2.2.3.3">1</cn></apply></apply></list><apply id="S3.Ex3.m1.2.2.1.1.5.cmml" xref="S3.Ex3.m1.2.2.1.1.5"><times id="S3.Ex3.m1.2.2.1.1.5.4.cmml" xref="S3.Ex3.m1.2.2.1.1.5.4"></times><ci id="S3.Ex3.m1.2.2.1.1.5.5.cmml" xref="S3.Ex3.m1.2.2.1.1.5.5">ℳ</ci><vector id="S3.Ex3.m1.2.2.1.1.5.3.4.cmml" xref="S3.Ex3.m1.2.2.1.1.5.3.3"><apply id="S3.Ex3.m1.2.2.1.1.3.1.1.1.cmml" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1"><csymbol cd="ambiguous" id="S3.Ex3.m1.2.2.1.1.3.1.1.1.1.cmml" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1">subscript</csymbol><ci id="S3.Ex3.m1.2.2.1.1.3.1.1.1.2.cmml" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.2">𝑝</ci><apply id="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.cmml" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.3"><times id="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.1.cmml" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.1"></times><ci id="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.2.cmml" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.2">𝑐</ci><ci id="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.3.cmml" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.3">𝑜</ci><ci id="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.4.cmml" xref="S3.Ex3.m1.2.2.1.1.3.1.1.1.3.4">𝑛</ci></apply></apply><ci id="S3.Ex3.m1.1.1.cmml" xref="S3.Ex3.m1.1.1">𝑞</ci><list id="S3.Ex3.m1.2.2.1.1.4.2.2.2.3.cmml" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.2"><apply id="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1.cmml" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1"><csymbol cd="ambiguous" id="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1.1.cmml" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1">subscript</csymbol><ci id="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1.2.cmml" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1.2">𝐷</ci><cn id="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1.3.cmml" type="integer" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.1.1.3">0</cn></apply><apply id="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2.cmml" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2"><csymbol cd="ambiguous" id="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2.1.cmml" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2">subscript</csymbol><ci id="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2.2.cmml" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2.2">𝑆</ci><cn id="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2.3.cmml" type="integer" xref="S3.Ex3.m1.2.2.1.1.4.2.2.2.2.2.3">0</cn></apply></list><list id="S3.Ex3.m1.2.2.1.1.5.3.3.3.3.cmml" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.2"><apply id="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1.cmml" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1"><csymbol cd="ambiguous" id="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1.1.cmml" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1">subscript</csymbol><ci id="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1.2.cmml" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1.2">𝐷</ci><ci id="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1.3.cmml" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.1.1.3">𝑗</ci></apply><apply id="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2.cmml" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2"><csymbol cd="ambiguous" id="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2.1.cmml" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2">subscript</csymbol><ci id="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2.2.cmml" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2.2">𝑆</ci><ci id="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2.3.cmml" xref="S3.Ex3.m1.2.2.1.1.5.3.3.3.2.2.3">𝑗</ci></apply></list></vector></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.Ex3.m1.2c">\langle D_{j+1},S_{j+1}\rangle=\mathcal{M}(p_{con},q,\langle D_{0},S_{0}% \rangle,\langle D_{j},S_{j}\rangle).</annotation><annotation encoding="application/x-llamapun" id="S3.Ex3.m1.2d">⟨ italic_D start_POSTSUBSCRIPT italic_j + 1 end_POSTSUBSCRIPT , italic_S start_POSTSUBSCRIPT italic_j + 1 end_POSTSUBSCRIPT ⟩ = caligraphic_M ( italic_p start_POSTSUBSCRIPT italic_c italic_o italic_n end_POSTSUBSCRIPT , italic_q , ⟨ italic_D start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , italic_S start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT ⟩ , ⟨ italic_D start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT , italic_S start_POSTSUBSCRIPT italic_j end_POSTSUBSCRIPT ⟩ ) .</annotation></semantics></math></td><td></td></tr></tbody></table>

We find that this is especially helpful in comparing the reliability of conflicting knowledge and addressing knowledge conflicts. Moreover, this knowledge consolidation process can run iteratively for t𝑡titalic\_t times to improve the context to be more and more useful. Users can assign a larger number of iterations when the context is lengthy.

### 3.5 Answer Finalization

In the last step, we prompt the LLM (with pa⁢n⁢ssubscript𝑝𝑎𝑛𝑠p\_{ans}italic\_p start\_POSTSUBSCRIPT italic\_a italic\_n italic\_s end\_POSTSUBSCRIPT in Appendix [A](https://arxiv.org/html/2410.07176v1#A1 "Appendix A Prompt Template for Astute RAG ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")) to generate one answer based on each group of passages (⟨Dt,St⟩subscript𝐷𝑡subscript𝑆𝑡\\langle D\_{t},S\_{t}\\rangle⟨ italic\_D start\_POSTSUBSCRIPT italic\_t end\_POSTSUBSCRIPT , italic\_S start\_POSTSUBSCRIPT italic\_t end\_POSTSUBSCRIPT ⟩), and then compare their reliability and select the most reliable one as the final answer. This comparison allows the LLM to comprehensively consider knowledge source, cross-source confirmation, frequency, and information thoroughness when making the final decision. Notably, this step can be merged into the last knowledge consolidation step to reduce the inference complexity (the amount of prediction API calls) using a combined prompt:

<table id="S3.Ex4"><tbody><tr><td></td><td><math alttext="a=\mathcal{M}(p_{ans},q,\langle D_{0},S_{0}\rangle,\langle D_{t},S_{t}\rangle)." display="block" id="S3.Ex4.m1.2"><semantics id="S3.Ex4.m1.2a"><mrow id="S3.Ex4.m1.2.2.1" xref="S3.Ex4.m1.2.2.1.1.cmml"><mrow id="S3.Ex4.m1.2.2.1.1" xref="S3.Ex4.m1.2.2.1.1.cmml"><mi id="S3.Ex4.m1.2.2.1.1.5" xref="S3.Ex4.m1.2.2.1.1.5.cmml">a</mi><mo id="S3.Ex4.m1.2.2.1.1.4" xref="S3.Ex4.m1.2.2.1.1.4.cmml">=</mo><mrow id="S3.Ex4.m1.2.2.1.1.3" xref="S3.Ex4.m1.2.2.1.1.3.cmml"><mi id="S3.Ex4.m1.2.2.1.1.3.5" xref="S3.Ex4.m1.2.2.1.1.3.5.cmml">ℳ</mi><mo id="S3.Ex4.m1.2.2.1.1.3.4" xref="S3.Ex4.m1.2.2.1.1.3.4.cmml">⁢</mo><mrow id="S3.Ex4.m1.2.2.1.1.3.3.3" xref="S3.Ex4.m1.2.2.1.1.3.3.4.cmml"><mo id="S3.Ex4.m1.2.2.1.1.3.3.3.4" stretchy="false" xref="S3.Ex4.m1.2.2.1.1.3.3.4.cmml">(</mo><msub id="S3.Ex4.m1.2.2.1.1.1.1.1.1" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.cmml"><mi id="S3.Ex4.m1.2.2.1.1.1.1.1.1.2" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.2.cmml">p</mi><mrow id="S3.Ex4.m1.2.2.1.1.1.1.1.1.3" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.cmml"><mi id="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.2" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.2.cmml">a</mi><mo id="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.1" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.1.cmml">⁢</mo><mi id="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.3" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.3.cmml">n</mi><mo id="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.1a" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.1.cmml">⁢</mo><mi id="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.4" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.4.cmml">s</mi></mrow></msub><mo id="S3.Ex4.m1.2.2.1.1.3.3.3.5" xref="S3.Ex4.m1.2.2.1.1.3.3.4.cmml">,</mo><mi id="S3.Ex4.m1.1.1" xref="S3.Ex4.m1.1.1.cmml">q</mi><mo id="S3.Ex4.m1.2.2.1.1.3.3.3.6" xref="S3.Ex4.m1.2.2.1.1.3.3.4.cmml">,</mo><mrow id="S3.Ex4.m1.2.2.1.1.2.2.2.2.2" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.3.cmml"><mo id="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.3" stretchy="false" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.3.cmml">⟨</mo><msub id="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1.cmml"><mi id="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1.2" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1.2.cmml">D</mi><mn id="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1.3" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1.3.cmml">0</mn></msub><mo id="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.4" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.3.cmml">,</mo><msub id="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2.cmml"><mi id="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2.2" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2.2.cmml">S</mi><mn id="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2.3" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2.3.cmml">0</mn></msub><mo id="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.5" stretchy="false" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.3.cmml">⟩</mo></mrow><mo id="S3.Ex4.m1.2.2.1.1.3.3.3.7" xref="S3.Ex4.m1.2.2.1.1.3.3.4.cmml">,</mo><mrow id="S3.Ex4.m1.2.2.1.1.3.3.3.3.2" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.3.cmml"><mo id="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.3" stretchy="false" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.3.cmml">⟨</mo><msub id="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1.cmml"><mi id="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1.2" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1.2.cmml">D</mi><mi id="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1.3" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1.3.cmml">t</mi></msub><mo id="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.4" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.3.cmml">,</mo><msub id="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2.cmml"><mi id="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2.2" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2.2.cmml">S</mi><mi id="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2.3" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2.3.cmml">t</mi></msub><mo id="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.5" stretchy="false" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.3.cmml">⟩</mo></mrow><mo id="S3.Ex4.m1.2.2.1.1.3.3.3.8" stretchy="false" xref="S3.Ex4.m1.2.2.1.1.3.3.4.cmml">)</mo></mrow></mrow></mrow><mo id="S3.Ex4.m1.2.2.1.2" lspace="0em" xref="S3.Ex4.m1.2.2.1.1.cmml">.</mo></mrow><annotation-xml encoding="MathML-Content" id="S3.Ex4.m1.2b"><apply id="S3.Ex4.m1.2.2.1.1.cmml" xref="S3.Ex4.m1.2.2.1"><eq id="S3.Ex4.m1.2.2.1.1.4.cmml" xref="S3.Ex4.m1.2.2.1.1.4"></eq><ci id="S3.Ex4.m1.2.2.1.1.5.cmml" xref="S3.Ex4.m1.2.2.1.1.5">𝑎</ci><apply id="S3.Ex4.m1.2.2.1.1.3.cmml" xref="S3.Ex4.m1.2.2.1.1.3"><times id="S3.Ex4.m1.2.2.1.1.3.4.cmml" xref="S3.Ex4.m1.2.2.1.1.3.4"></times><ci id="S3.Ex4.m1.2.2.1.1.3.5.cmml" xref="S3.Ex4.m1.2.2.1.1.3.5">ℳ</ci><vector id="S3.Ex4.m1.2.2.1.1.3.3.4.cmml" xref="S3.Ex4.m1.2.2.1.1.3.3.3"><apply id="S3.Ex4.m1.2.2.1.1.1.1.1.1.cmml" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1"><csymbol cd="ambiguous" id="S3.Ex4.m1.2.2.1.1.1.1.1.1.1.cmml" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1">subscript</csymbol><ci id="S3.Ex4.m1.2.2.1.1.1.1.1.1.2.cmml" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.2">𝑝</ci><apply id="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.cmml" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.3"><times id="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.1.cmml" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.1"></times><ci id="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.2.cmml" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.2">𝑎</ci><ci id="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.3.cmml" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.3">𝑛</ci><ci id="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.4.cmml" xref="S3.Ex4.m1.2.2.1.1.1.1.1.1.3.4">𝑠</ci></apply></apply><ci id="S3.Ex4.m1.1.1.cmml" xref="S3.Ex4.m1.1.1">𝑞</ci><list id="S3.Ex4.m1.2.2.1.1.2.2.2.2.3.cmml" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.2"><apply id="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1.cmml" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1"><csymbol cd="ambiguous" id="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1.1.cmml" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1">subscript</csymbol><ci id="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1.2.cmml" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1.2">𝐷</ci><cn id="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1.3.cmml" type="integer" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.1.1.3">0</cn></apply><apply id="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2.cmml" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2"><csymbol cd="ambiguous" id="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2.1.cmml" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2">subscript</csymbol><ci id="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2.2.cmml" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2.2">𝑆</ci><cn id="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2.3.cmml" type="integer" xref="S3.Ex4.m1.2.2.1.1.2.2.2.2.2.2.3">0</cn></apply></list><list id="S3.Ex4.m1.2.2.1.1.3.3.3.3.3.cmml" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.2"><apply id="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1.cmml" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1"><csymbol cd="ambiguous" id="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1.1.cmml" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1">subscript</csymbol><ci id="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1.2.cmml" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1.2">𝐷</ci><ci id="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1.3.cmml" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.1.1.3">𝑡</ci></apply><apply id="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2.cmml" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2"><csymbol cd="ambiguous" id="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2.1.cmml" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2">subscript</csymbol><ci id="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2.2.cmml" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2.2">𝑆</ci><ci id="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2.3.cmml" xref="S3.Ex4.m1.2.2.1.1.3.3.3.3.2.2.3">𝑡</ci></apply></list></vector></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.Ex4.m1.2c">a=\mathcal{M}(p_{ans},q,\langle D_{0},S_{0}\rangle,\langle D_{t},S_{t}\rangle).</annotation><annotation encoding="application/x-llamapun" id="S3.Ex4.m1.2d">italic_a = caligraphic_M ( italic_p start_POSTSUBSCRIPT italic_a italic_n italic_s end_POSTSUBSCRIPT , italic_q , ⟨ italic_D start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT , italic_S start_POSTSUBSCRIPT 0 end_POSTSUBSCRIPT ⟩ , ⟨ italic_D start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT , italic_S start_POSTSUBSCRIPT italic_t end_POSTSUBSCRIPT ⟩ ) .</annotation></semantics></math></td><td></td></tr></tbody></table>

When t\=1𝑡1t=1italic\_t = 1, the initial passages will be fed into the model directly for knowledge consolidation and subsequent answering: a\=ℳ⁢(pa⁢n⁢s,q,⟨D0,S0⟩).𝑎ℳsubscript𝑝𝑎𝑛𝑠𝑞subscript𝐷0subscript𝑆0a=\\mathcal{M}(p\_{ans},q,\\langle D\_{0},S\_{0}\\rangle).italic\_a = caligraphic\_M ( italic\_p start\_POSTSUBSCRIPT italic\_a italic\_n italic\_s end\_POSTSUBSCRIPT , italic\_q , ⟨ italic\_D start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT , italic\_S start\_POSTSUBSCRIPT 0 end\_POSTSUBSCRIPT ⟩ ) .

4 Experiments
-------------

We evaluate the effectiveness of Astute RAG on overcoming imperfect retrieval augmentation and addressing knowledge conflicts. In this section, we first introduce the experiment setting in detail (Section [4.1](https://arxiv.org/html/2410.07176v1#S4.SS1 "4.1 Experimental Settings ‣ 4 Experiments ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")). Then, we compare the performance of Astute RAG with various baselines on diverse datasets (Section [4.2](https://arxiv.org/html/2410.07176v1#S4.SS2 "4.2 Main Results ‣ 4 Experiments ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")). Finally, we provide in-depth analyses (Section [4.3](https://arxiv.org/html/2410.07176v1#S4.SS3 "4.3 Analyses ‣ 4 Experiments ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models")).

Table 1: Main results on Claude under zero-shot setting, showing the accuracy of different benchmark methods vs. Astute RAG, along with their prediction complexity, in number of prediction API calls. Best scores are in bold.

### 4.1 Experimental Settings

Datasets and metrics. We conduct experiments on the data collected in Section [2](https://arxiv.org/html/2410.07176v1#S2 "2 Imperfect Retrieval: The Pitfall of RAG ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models") consisting of data from NQ, TriviaQA, BioASQ, and PopQA. For each instance from these datasets, we provide 10 passages collected under a realistic retrieval setting: for each question in our benchmark, we query Google Search to retrieve the top 30 results and select the first 10 accessible websites. From each retrieved website, we extract the paragraph corresponding to the snippet provided in Google Search results as the retrieved passage.. Most of the retrieval results contains natural noise with irrelevant or misleading information. We do not consider enhancements to the retrieval side, such as query rewriting, as such enhancements are typically already incorporated into commercial information retrieval systems. Notably, we do not select questions or annotate answers based on the retrieval results. This setting allows us to analyze the severity of imperfect retrieval in real-world RAG. It distinguishes our benchmark from previous ones that employ synthetic retrieval corruptions or that unintentionally reduce the frequency of imperfect retrieval with biased construction protocols (Chen et al., [2024a](https://arxiv.org/html/2410.07176v1#bib.bib5); Yang et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib38)). We also evaluate our method on RGB (Chen et al., [2024a](https://arxiv.org/html/2410.07176v1#bib.bib5)), a RAG diagnostic benchmark evaluating several crucial RAG abilities. Specifically, we choose the English subset of RGB focusing on noise robustness. The benchmark have positive and negative passage sets for each question. We select five negative documents per question as the context to form a worst-case scenario. All the data in these datasets are short-form QA. Following previous work (Xiang et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib32); Wei et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib31); Mallen et al., [2023](https://arxiv.org/html/2410.07176v1#bib.bib20)), a model response is considered correct if it contains the ground-truth answer. To enhance evaluation reliability, we prompt LLMs to enclose the exact answer within special tokens, extracting them as the final responses.

General Settings of LLMs and RAG. We conduct experiments on two advanced LLMs, including Gemini 1.5 Pro555https://deepmind.google/technologies/gemini/pro/ (gemini-1.5-pro-002) and Claude 3.5 Sonnet666https://www.anthropic.com/news/claude-3-5-sonnet (claude-3-5-sonnet@20240620). The generation temperature is set to 0 and the maximum output tokens is set to 1,024, if not specified otherwise. By default, the passages are presented in the prompt by reversed order. All experiments are under the zero-shot setting for controlled evaluation, where no demonstrations for QA or method-specific steps are provided.

Baselines. We compare Astute RAG with various RAG methods designed for enhanced robustness and representative inference strategies designed to improve response trustworthiness. USC (Chen et al., [2024b](https://arxiv.org/html/2410.07176v1#bib.bib6)) is the universal self-consistency method that samples multiple LLM responses given the same context and aggregates the answers. It provides a reference of naive improvements using additional API calls. The temperature for sampling responses in this baseline is set to 0.7. Genread (Yu et al., [2023a](https://arxiv.org/html/2410.07176v1#bib.bib40)) augments retrieved passages with LLM-generated passages. It provide a reference of presenting passages from both internal and external knowledge in the prompt without effectively combining them. RobustRAG (Xiang et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib32)) aggregates answers from each independent passage to provide certifiable robustness. We use the keyword aggregation variant as it is shown to be the best-performing variant on advanced LLMs. InstructRAG (Wei et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib31)) instructs the LLM to provide a rationale connecting the answer with information in passages. For a fair comparison, we use the instructions without training or in-context learning. Self-Route (Xu et al., [2024a](https://arxiv.org/html/2410.07176v1#bib.bib35)) adaptively switches between LLMs with and without RAG.777The original Self-Route switches between RAG and long-context LLMs, while our implementation switches between LLMs with and without RAG to better align with the problem formulation in this paper. This baseline provides a reference of switching between LLMs’ internal and external knowledge.

Implementation Details of Astute RAG. The prompt templates for Astute RAG can be found in Appendix [A](https://arxiv.org/html/2410.07176v1#A1 "Appendix A Prompt Template for Astute RAG ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models"). By default, we use 2 API calls per query, setting t\=1𝑡1t=1italic\_t = 1 to merge the prompt for knowledge consolidation and answer finalization. For adaptive generation of internal knowledge, we prompt the LLM to generate no more than one passage.

Table 2: Main results on Gemini under zero-shot setting, showing the accuracy of different benchmark methods vs. Astute RAG, along with their prediction complexity, in number of prediction API calls. Best scores are in bold.

### 4.2 Main Results

Table [1](https://arxiv.org/html/2410.07176v1#S4.T1 "Table 1 ‣ 4 Experiments ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models") and Table [2](https://arxiv.org/html/2410.07176v1#S4.T2 "Table 2 ‣ 4.1 Experimental Settings ‣ 4 Experiments ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models") presents the results on data with realistic retrieval augmentation for each dataset. By comparing RAG and No RAG, we find that retrieved passages might not always bring benefits to downstream performance – on NQ and TriviaQA, RAG performance lags behind No RAG. We attribute this to that the questions being covered by the LLM’s internal knowledge and the noise in retrieval results misleading the LLM. In contrast, on BioASQ and PopQA, which focus on domain-specific and long-tail questions, RAG significantly improves LLM performance. However, due to imperfect retrieval augmentation, the absolute performance still remains to be unsatisfactory. Among all baselines, no single method consistently outperforms others across all datasets. This observation highlights that these baselines are tailored to distinct settings and may not be universally applicable. For instance, InstructRAG is more effective on TriviaQA, achieving the best performance among all baselines with both Claude and Gemini. In contrast, Self-Route performs better than InstructRAG on both NQ and BioASQ. Moreover, RobustRAG achieves very different performance when applied to Gemini and Claude. Through in-depth analysis, we find that RobustRAG with Gemini exhibits a high refusal rate (refuse to answer) in responses. We attribute this instability to the varying method designs of the baselines, which are tailored for different scenarios, resulting in inconsistent improvement across datasets. Overall, InstructRAG and Self-Route demonstrates the best performance among all baselines when applied to Claude and Gemini respectively. We also note that increasing the number of API calls does not necessarily correlate with improved performance.

Astute RAG consistently outperforms baselines across all datasets of different properties. The overall improvement compared with the best baseline is relatively 6.85% on Claude and 4.13% on Gemini, and the improvements in domain-specific questions are much higher. These results highlight the effectiveness of Astute RAG in overcoming imperfect retrieval augmentation. On Claude, adding more iteration of knowledge consolidation leads to consist improvement. The improvement margin becomes lower when t𝑡titalic\_t becomes larger. This is because after each iteration, the remaining improvement space for knowledge consolidation becomes smaller. On Gemini, increasing t𝑡titalic\_t primarily benefits BioASQ and PopQA. These two datasets rely more heavily on external knowledge, and iterative knowledge consolidation helps mitigate noise within this external information. Performance on NQ and TriviaQA does not improve further when t𝑡titalic\_t reaches 3. We attribute this to the less critical role of external knowledge in these datasets. For setting consistency and efficiency, we set the parameter m^^𝑚\\hat{m}over^ start\_ARG italic\_m end\_ARG to a smaller value, limiting the influence of internal knowledge.

### 4.3 Analyses

Performance by retrieval precision. We compare the performance of Astute RAG and baselines across different subsets partitioned by their retrieval precision, on our collected data with Claude as the LLM. As shown in Figure [4](https://arxiv.org/html/2410.07176v1#S4.F4 "Figure 4 ‣ 4.3 Analyses ‣ 4 Experiments ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models"), Astute RAG achieves consistently better performance than all baselines across different retrieval precision, indicating its effectiveness in improving RAG trustworthiness in broad scenarios. Notably, Astute RAG does not sacrifice performance gain under high retrieval quality in exchange for improvement under low retrieval quality. When the retrieval quality is extremely low (close to zero retrieval precision), all other RAG variants underperforms the ’No RAG’ baseline, except for the proposed Astute RAG. This observation aligns with the worst-case results on RGB. It demonstrates the difficulty in overcoming imperfect retrieval augmentation, and verify the effectiveness of Astute RAG in doing so.

![Image 4: Refer to caption](https://arxiv.org/html/2410.07176v1/extracted/5914248/figure/perf_dist.png)

(a) Performance by Retrieval Precision

![Image 5: Refer to caption](https://arxiv.org/html/2410.07176v1/extracted/5914248/figure/conflicts.png)

(b) Performance by Knowledge Conflicts

![Image 6: Refer to caption](https://arxiv.org/html/2410.07176v1/extracted/5914248/figure/rgb.png)

(c) Worst-case Performance on RGB

Figure 4: Analysis results. (a) Performance of Claude across different buckets ranked by retrieval precision. (b) Performance of Claude on conflicting and consistent instances between No RAG and RAG. (c) Worst-case performance of Claude on RGB, where all retrieved passages are negative. Astute RAG reaches a performance close to No RAG, while other RAG systems are far behind.

Effectiveness in addressing knowledge conflicts. We split our collected data in to three subset according to the answers from Claude, with and without RAG. The answers from two inference methods can be both correct, both incorrect, or conflicting with one being correct. These three subsets represents the three situations between internal and external knowledge. The results are shown in Figure [4](https://arxiv.org/html/2410.07176v1#S4.F4 "Figure 4 ‣ 4.3 Analyses ‣ 4 Experiments ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models"). On the conflicting subset, Astute RAG successfully chooses the correct answer in approximately 80% of cases, being the most effective method in addressing knowledge conflicts. Notably, Astute RAG even brings performance improvement on the subset where neither internal nor external knowledge alone leads to the correct answer. This indicates that Astute RAG can effectively combine partially-correct information from LLM-internal and external knowledge, to achieve the correct answer through collective information across them.

Worst-case performance on RGB.. Figure [4](https://arxiv.org/html/2410.07176v1#S4.F4 "Figure 4 ‣ 4.3 Analyses ‣ 4 Experiments ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models") presents the results under the worst-case setting on RGB where all retrieved documents are negative. It demonstrates the noise robustness of Astute RAG and baseline RAG methods. The performance gap between RAG and No RAG exceeds 50 points, highlighting the detrimental impact of imperfect retrieval results and emphasizing the importance of providing robust safeguards against worst-case scenarios. While the baseline RAG methods outperform the original RAG, they still obviously fall behind No RAG. Astute RAG is the only RAG method that reaches a performance close to No RAG under the worst-case scenario, further supporting its effectiveness in addressing imperfect retrieval augmentation.

Qualitative study. In Figure [5](https://arxiv.org/html/2410.07176v1#S4.F5 "Figure 5 ‣ 4.3 Analyses ‣ 4 Experiments ‣ Astute RAG: Overcoming Imperfect Retrieval Augmentation and Knowledge Conflicts for Large Language Models"), we present two representative examples showing the intermediate outputs of Astute RAG. In the first example, LLM without RAG generates a wrong answer, while RAG returns a correct answer. Astute RAG successfully identified the incorrect information in its generated passage and an external passage, avoiding confirmation bias Tan et al. ([2024](https://arxiv.org/html/2410.07176v1#bib.bib24)). In the second example, LLM alone is correct, while RAG is incorrect due to the noisy retrieval results. Astute RAG detected the correct answer from noisy retrieved information by checking with its internal knowledge.

![Image 7: Refer to caption](https://arxiv.org/html/2410.07176v1/extracted/5914248/figure/qual_2.png)

Figure 5: Qualitative examples. Top: Astute RAG identified the error in internal knowledge (i.e., generated passage) by confirming with external sources. Bottom: Astute RAG detected the correct answer from noisy retrieved information by checking with its internal knowledge. Standard RAG does not provide an answer because the retrieved passages are too noisy.

5 Related Work
--------------

Retrieval augmented generation (RAG) seeks to address the inherent knowledge limitation of LLMs with passages retrieved from external sources of information such as private corpora or public knowledge bases (Guu et al., [2020](https://arxiv.org/html/2410.07176v1#bib.bib11); Lewis et al., [2020](https://arxiv.org/html/2410.07176v1#bib.bib17); Borgeaud et al., [2022](https://arxiv.org/html/2410.07176v1#bib.bib4)). Given the widespread adoption of RAG in various real-world applications, including risk-sensitive domains, the negative impact of noisy information within retrieved passages has garnered increasing attention (Cuconasu et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib7)). Recent work has sought to enhance the robustness of RAG systems against noise from various perspectives, including training LLMs with noisy context (Yu et al., [2023b](https://arxiv.org/html/2410.07176v1#bib.bib41); Yoran et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib39); Pan et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib21); Fang et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib9)), training small models to filter out irrelevant passages (Wang et al., [2023c](https://arxiv.org/html/2410.07176v1#bib.bib29); Xu et al., [2023](https://arxiv.org/html/2410.07176v1#bib.bib34)), passage reranking (Yu et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib42); Glass et al., [2022](https://arxiv.org/html/2410.07176v1#bib.bib10)), dynamic and iterative retrieval (Jiang et al., [2023](https://arxiv.org/html/2410.07176v1#bib.bib13); Asai et al., [2023](https://arxiv.org/html/2410.07176v1#bib.bib1); Yan et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib37)), query rewriting (Ma et al., [2023](https://arxiv.org/html/2410.07176v1#bib.bib19)), and speculative drafting (Wang et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib30)). These studies focus on distinct modules or stages of RAG systems and are orthogonal to our work.

Our work focuses on enhancing RAG robustness at the post-retrieval stage, after retrieved passages have been provided. On this topic, RobustRAG (Xiang et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib32)) aggregates answers from each independent passage to provide certifiable robustness. InstructRAG (Wei et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib31)) instructs the LLM to provide a rationale connecting the answer with information in passages. MADRA (Wang et al., [2023b](https://arxiv.org/html/2410.07176v1#bib.bib28)) applies multi-agent debate to select helpful evidence. However, these works do not explicitly incorporate internal knowledge to recover from RAG failures and may therefore collapse when the majority of retrieved passages are negative. In terms of emphasizing internal knowledge of LLMs in RAG, recent work has explored using LLM-generated passage as context (Yu et al., [2023a](https://arxiv.org/html/2410.07176v1#bib.bib40); Zhang et al., [2023](https://arxiv.org/html/2410.07176v1#bib.bib43)), adaptively switching between LLMs with and without RAG (Xu et al., [2024a](https://arxiv.org/html/2410.07176v1#bib.bib35); Mallen et al., [2023](https://arxiv.org/html/2410.07176v1#bib.bib20); Jeong et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib12)), and combining answers from internal and external knowledge through contrastive decoding (Zhao et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib44); Jin et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib14)). We focus on a black-box setting where no further training is required, directly addressing knowledge conflicts to combine the helpful information from both sides and achieve more reliable answers.

6 Conclusion
------------

Our paper investigates the impact of imperfect retrieval on the performance of RAG systems and identifies knowledge conflicts as a key challenge. To address this, we introduce Astute RAG, a novel approach that leverages the internal knowledge of LLMs and iteratively refines the generated responses by consolidating internal and external knowledge in a source way. Our empirical results demonstrate the effectiveness of Astute RAG in mitigating the negative effects of imperfect retrieval and improving the robustness of RAG systems, particularly in challenging scenarios with unreliable external sources.

Among the limitations, Astute RAG’s effectiveness hinges on the capabilities of advanced LLMs with strong instruction-following and reasoning abilities, hence potentially more limited applicability with less sophisticated LLMs. As an important future direction, extending the experimental setup to include longer outputs would be important, where the challenges of imperfect retrieval and knowledge conflicts may be even more pronounced. Furthermore, a comprehensive analysis of the impact of various context types (Balachandran et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib3)) would enhance the understanding of the proposed method’s effectiveness. Future work can also extend our method beyond LLMs and RAG, such as addressing knowledge conflicts in multimodal settings (Zhu et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib45)).

Acknowledgement
---------------

We would like to thank Jinsung Yoon for valuable discussions and insights that helped to improve this paper. We would also like to thank all other colleagues from Google Cloud AI Research for their valuable feedback.

References
----------

*   Asai et al. (2023) A. Asai, Z. Wu, Y. Wang, A. Sil, and H. Hajishirzi. Self-rag: Learning to retrieve, generate, and critique through self-reflection. In _The Twelfth International Conference on Learning Representations_, 2023.
*   Bai et al. (2022) Y. Bai, S. Kadavath, S. Kundu, A. Askell, J. Kernion, A. Jones, A. Chen, A. Goldie, A. Mirhoseini, C. McKinnon, et al. Constitutional ai: Harmlessness from ai feedback. _arXiv preprint arXiv:2212.08073_, 2022.
*   Balachandran et al. (2024) V. Balachandran, J. Chen, N. Joshi, B. Nushi, H. Palangi, E. Salinas, V. Vineet, J. Woffinden-Luey, and S. Yousefi. Eureka: Evaluating and understanding large foundation models. _arXiv preprint arXiv:2409.10566_, 2024.
*   Borgeaud et al. (2022) S. Borgeaud, A. Mensch, J. Hoffmann, T. Cai, E. Rutherford, K. Millican, G. B. Van Den Driessche, J.-B. Lespiau, B. Damoc, A. Clark, et al. Improving language models by retrieving from trillions of tokens. In _International conference on machine learning_, pages 2206–2240. PMLR, 2022.
*   Chen et al. (2024a) J. Chen, H. Lin, X. Han, and L. Sun. Benchmarking large language models in retrieval-augmented generation. In _Proceedings of the AAAI Conference on Artificial Intelligence_, volume 38, pages 17754–17762, 2024a.
*   Chen et al. (2024b) X. Chen, R. Aksitov, U. Alon, J. Ren, K. Xiao, P. Yin, S. Prakash, C. Sutton, X. Wang, and D. Zhou. Universal self-consistency for large language models. In _ICML 2024 Workshop on In-Context Learning_, 2024b.
*   Cuconasu et al. (2024) F. Cuconasu, G. Trappolini, F. Siciliano, S. Filice, C. Campagnano, Y. Maarek, N. Tonellotto, and F. Silvestri. The power of noise: Redefining retrieval for rag systems. In _Proceedings of the 47th International ACM SIGIR Conference on Research and Development in Information Retrieval_, pages 719–729, 2024.
*   Dai et al. (2024) S. Dai, C. Xu, S. Xu, L. Pang, Z. Dong, and J. Xu. Unifying bias and unfairness in information retrieval: A survey of challenges and opportunities with large language models. _arXiv preprint arXiv:2404.11457_, 2024.
*   Fang et al. (2024) F. Fang, Y. Bai, S. Ni, M. Yang, X. Chen, and R. Xu. Enhancing noise robustness of retrieval-augmented language models with adaptive adversarial training. _arXiv preprint arXiv:2405.20978_, 2024.
*   Glass et al. (2022) M. Glass, G. Rossiello, M. F. M. Chowdhury, A. Naik, P. Cai, and A. Gliozzo. Re2g: Retrieve, rerank, generate. In _Proceedings of the 2022 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies_, pages 2701–2715, 2022.
*   Guu et al. (2020) K. Guu, K. Lee, Z. Tung, P. Pasupat, and M. Chang. Retrieval augmented language model pre-training. In _International conference on machine learning_, pages 3929–3938. PMLR, 2020.
*   Jeong et al. (2024) S. Jeong, J. Baek, S. Cho, S. J. Hwang, and J. C. Park. Adaptive-rag: Learning to adapt retrieval-augmented large language models through question complexity. In _Proceedings of the 2024 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (Volume 1: Long Papers)_, pages 7029–7043, 2024.
*   Jiang et al. (2023) Z. Jiang, F. F. Xu, L. Gao, Z. Sun, Q. Liu, J. Dwivedi-Yu, Y. Yang, J. Callan, and G. Neubig. Active retrieval augmented generation. In _Proceedings of the 2023 Conference on Empirical Methods in Natural Language Processing_, pages 7969–7992, 2023.
*   Jin et al. (2024) Z. Jin, P. Cao, Y. Chen, K. Liu, X. Jiang, J. Xu, L. Qiuxia, and J. Zhao. Tug-of-war between knowledge: Exploring and resolving knowledge conflicts in retrieval-augmented language models. In _Proceedings of the 2024 Joint International Conference on Computational Linguistics, Language Resources and Evaluation (LREC-COLING 2024)_, pages 16867–16878, 2024.
*   Joshi et al. (2017) M. Joshi, E. Choi, D. S. Weld, and L. Zettlemoyer. Triviaqa: A large scale distantly supervised challenge dataset for reading comprehension. In _Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)_, pages 1601–1611, 2017.
*   Kwiatkowski et al. (2019) T. Kwiatkowski, J. Palomaki, O. Redfield, M. Collins, A. Parikh, C. Alberti, D. Epstein, I. Polosukhin, J. Devlin, K. Lee, et al. Natural questions: a benchmark for question answering research. _Transactions of the Association for Computational Linguistics_, 7:453–466, 2019.
*   Lewis et al. (2020) P. Lewis, E. Perez, A. Piktus, F. Petroni, V. Karpukhin, N. Goyal, H. Küttler, M. Lewis, W.-t. Yih, T. Rocktäschel, et al. Retrieval-augmented generation for knowledge-intensive nlp tasks. _Advances in Neural Information Processing Systems_, 33:9459–9474, 2020.
*   Longpre et al. (2021) S. Longpre, K. Perisetla, A. Chen, N. Ramesh, C. DuBois, and S. Singh. Entity-based knowledge conflicts in question answering. In _Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing_, 2021.
*   Ma et al. (2023) X. Ma, Y. Gong, P. He, H. Zhao, and N. Duan. Query rewriting in retrieval-augmented large language models. In _Proceedings of the 2023 Conference on Empirical Methods in Natural Language Processing_, pages 5303–5315, 2023.
*   Mallen et al. (2023) A. Mallen, A. Asai, V. Zhong, R. Das, D. Khashabi, and H. Hajishirzi. When not to trust language models: Investigating effectiveness of parametric and non-parametric memories. In _Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)_, pages 9802–9822, 2023.
*   Pan et al. (2024) R. Pan, B. Cao, H. Lin, X. Han, J. Zheng, S. Wang, X. Cai, and L. Sun. Not all contexts are equal: Teaching llms credibility-aware generation. _arXiv preprint arXiv:2404.06809_, 2024.
*   Shao et al. (2024) R. Shao, J. He, A. Asai, W. Shi, T. Dettmers, S. Min, L. Zettlemoyer, and P. W. Koh. Scaling retrieval-based language models with a trillion-token datastore. _arXiv preprint arXiv:2407.12854_, 2024.
*   Su et al. (2024) H. Su, H. Yen, M. Xia, W. Shi, N. Muennighoff, H.-y. Wang, H. Liu, Q. Shi, Z. S. Siegel, M. Tang, et al. Bright: A realistic and challenging benchmark for reasoning-intensive retrieval. _arXiv preprint arXiv:2407.12883_, 2024.
*   Tan et al. (2024) H. Tan, F. Sun, W. Yang, Y. Wang, Q. Cao, and X. Cheng. Blinded by generated contexts: How language models merge generated and retrieved contexts for open-domain qa? _arXiv preprint arXiv:2401.11911_, 2024.
*   Thakur et al. (2024) N. Thakur, N. Reimers, A. Rücklé, A. Srivastava, and I. Gurevych. Beir: A heterogeneous benchmark for zero-shot evaluation of information retrieval models. In _Thirty-fifth Conference on Neural Information Processing Systems Datasets and Benchmarks Track (Round 2)_, 2024.
*   Tsatsaronis et al. (2015) G. Tsatsaronis, G. Balikas, P. Malakasiotis, I. Partalas, M. Zschunke, M. R. Alvers, D. Weissenborn, A. Krithara, S. Petridis, D. Polychronopoulos, et al. An overview of the bioasq large-scale biomedical semantic indexing and question answering competition. _BMC bioinformatics_, 16:1–28, 2015.
*   Wang et al. (2023a) F. Wang, W. Mo, Y. Wang, W. Zhou, and M. Chen. A causal view of entity bias in (large) language models. In _Findings of the Association for Computational Linguistics: EMNLP 2023_, pages 15173–15184, 2023a.
*   Wang et al. (2023b) H. Wang, X. Du, W. Yu, Q. Chen, K. Zhu, Z. Chu, L. Yan, and Y. Guan. Apollo’s oracle: Retrieval-augmented reasoning in multi-agent debates. _arXiv preprint arXiv:2312.04854_, 2023b.
*   Wang et al. (2023c) Z. Wang, J. Araki, Z. Jiang, M. R. Parvez, and G. Neubig. Learning to filter context for retrieval-augmented generation. _arXiv preprint arXiv:2311.08377_, 2023c.
*   Wang et al. (2024) Z. Wang, Z. Wang, L. Le, H. S. Zheng, S. Mishra, V. Perot, Y. Zhang, A. Mattapalli, A. Taly, J. Shang, et al. Speculative rag: Enhancing retrieval augmented generation through drafting. _arXiv preprint arXiv:2407.08223_, 2024.
*   Wei et al. (2024) Z. Wei, W.-L. Chen, and Y. Meng. Instructrag: Instructing retrieval-augmented generation with explicit denoising. _arXiv preprint arXiv:2406.13629_, 2024.
*   Xiang et al. (2024) C. Xiang, T. Wu, Z. Zhong, D. Wagner, D. Chen, and P. Mittal. Certifiably robust rag against retrieval corruption. _arXiv preprint arXiv:2405.15556_, 2024.
*   Xie et al. (2024) J. Xie, K. Zhang, J. Chen, R. Lou, and Y. Su. Adaptive chameleon or stubborn sloth: Revealing the behavior of large language models in knowledge conflicts. In _The Twelfth International Conference on Learning Representations_, 2024.
*   Xu et al. (2023) F. Xu, W. Shi, and E. Choi. Recomp: Improving retrieval-augmented lms with compression and selective augmentation. _arXiv preprint arXiv:2310.04408_, 2023.
*   Xu et al. (2024a) P. Xu, W. Ping, X. Wu, L. McAfee, C. Zhu, Z. Liu, S. Subramanian, E. Bakhturina, M. Shoeybi, and B. Catanzaro. Retrieval meets long context large language models. In _The Twelfth International Conference on Learning Representations_, 2024a.
*   Xu et al. (2024b) R. Xu, Z. Qi, C. Wang, H. Wang, Y. Zhang, and W. Xu. Knowledge conflicts for llms: A survey. _arXiv preprint arXiv:2403.08319_, 2024b.
*   Yan et al. (2024) S.-Q. Yan, J.-C. Gu, Y. Zhu, and Z.-H. Ling. Corrective retrieval augmented generation. _arXiv preprint arXiv:2401.15884_, 2024.
*   Yang et al. (2024) X. Yang, K. Sun, H. Xin, Y. Sun, N. Bhalla, X. Chen, S. Choudhary, R. D. Gui, Z. W. Jiang, Z. Jiang, et al. Crag–comprehensive rag benchmark. _arXiv preprint arXiv:2406.04744_, 2024.
*   Yoran et al. (2024) O. Yoran, T. Wolfson, O. Ram, and J. Berant. Making retrieval-augmented language models robust to irrelevant context. In _The Twelfth International Conference on Learning Representations_, 2024.
*   Yu et al. (2023a) W. Yu, D. Iter, S. Wang, Y. Xu, M. Ju, S. Sanyal, C. Zhu, M. Zeng, and M. Jiang. Generate rather than retrieve: Large language models are strong context generators. In _The Eleventh International Conference on Learning Representations_, 2023a.
*   Yu et al. (2023b) W. Yu, H. Zhang, X. Pan, K. Ma, H. Wang, and D. Yu. Chain-of-note: Enhancing robustness in retrieval-augmented language models. _arXiv preprint arXiv:2311.09210_, 2023b.
*   Yu et al. (2024) Y. Yu, W. Ping, Z. Liu, B. Wang, J. You, C. Zhang, M. Shoeybi, and B. Catanzaro. Rankrag: Unifying context ranking with retrieval-augmented generation in llms. _arXiv preprint arXiv:2407.02485_, 2024.
*   Zhang et al. (2023) Y. Zhang, M. Khalifa, L. Logeswaran, M. Lee, H. Lee, and L. Wang. Merging generated and retrieved knowledge for open-domain qa. In _The 2023 Conference on Empirical Methods in Natural Language Processing_, 2023.
*   Zhao et al. (2024) Z. Zhao, E. Monti, J. Lehmann, and H. Assem. Enhancing contextual understanding in large language models through contrastive decoding. In _Proceedings of the 2024 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (Volume 1: Long Papers)_, pages 4225–4237, 2024.
*   Zhu et al. (2024) T. Zhu, Q. Liu, F. Wang, Z. Tu, and M. Chen. Unraveling cross-modality knowledge conflict in large vision-language models. _arXiv preprint arXiv:2410.03659_, 2024.
*   Zou et al. (2024) W. Zou, R. Geng, B. Wang, and J. Jia. Poisonedrag: Knowledge poisoning attacks to retrieval-augmented generation of large language models. _arXiv preprint arXiv:2402.07867_, 2024.

Appendix A Prompt Template for Astute RAG
-----------------------------------------

Prompt for Adaptive Passage Generation (pg⁢e⁢nsubscript𝑝𝑔𝑒𝑛p\_{gen}italic\_p start\_POSTSUBSCRIPT italic\_g italic\_e italic\_n end\_POSTSUBSCRIPT) Generate a document that provides accurate and relevant information to answer the given question. If the information is unclear or uncertain, explicitly state ’I don’t know’ to avoid any hallucinations. Question: {question} Document:

Prompt for Iterative Knowledge Consolidation (pc⁢o⁢nsubscript𝑝𝑐𝑜𝑛p\_{con}italic\_p start\_POSTSUBSCRIPT italic\_c italic\_o italic\_n end\_POSTSUBSCRIPT) Task: Consolidate information from both your own memorized documents and externally retrieved documents in response to the given question. \* For documents that provide consistent information, cluster them together and summarize the key details into a single, concise document. \* For documents with conflicting information, separate them into distinct documents, ensuring each captures the unique perspective or data. \* Exclude any information irrelevant to the query. For each new document created, clearly indicate: \* Whether the source was from memory or an external retrieval. \* The original document numbers for transparency. Initial Context: {context} Last Context: {context} Question: {question} New Context:

Prompt for Knowledge Consolidation and Answer Finalization (pa⁢n⁢ssubscript𝑝𝑎𝑛𝑠p\_{ans}italic\_p start\_POSTSUBSCRIPT italic\_a italic\_n italic\_s end\_POSTSUBSCRIPT) Task: Answer a given question using the consolidated information from both your own memorized documents and externally retrieved documents. Step 1: Consolidate information \* For documents that provide consistent information, cluster them together and summarize the key details into a single, concise document. \* For documents with conflicting information, separate them into distinct documents, ensuring each captures the unique perspective or data. \* Exclude any information irrelevant to the query. For each new document created, clearly indicate: \* Whether the source was from memory or an external retrieval. \* The original document numbers for transparency. Step 2: Propose Answers and Assign Confidence For each group of documents, propose a possible answer and assign a confidence score based on the credibility and agreement of the information. Step 3: Select the Final Answer After evaluating all groups, select the most accurate and well-supported answer. Highlight your exact answer within <<<ANSWER\>\>\> your answer <<</ANSWER\>\>\>. Initial Context: {context\_init} \[Consolidated Context: {context}\] # optional Question: {question} Answer:

Appendix B Data Collection
--------------------------

Encompassing a diverse range of natural questions, our benchmark consists of realistic retrieval results with Google Search999[https://developers.google.com/custom-search/v1/overview](https://developers.google.com/custom-search/v1/overview) as the retriever and the Web as the corpus. Notably, we do not select questions or annotate answers based on the retrieval results. This setting allows us to analyze the severity of imperfect retrieval in real-world RAG. It distinguishes our benchmark from previous ones that employ synthetic retrieval corruptions or that unintentionally reduce the frequency of imperfect retrieval with biased construction protocols (Chen et al., [2024a](https://arxiv.org/html/2410.07176v1#bib.bib5); Yang et al., [2024](https://arxiv.org/html/2410.07176v1#bib.bib38)). Overall, our benchmark contains 1,042 short-form question-answer pairs, each paired with 10 retrieved passages.

Question-answer pairs. We consider question-answer pairs from four datasets of different properties spanning across general questions, domain-specific questions, and long-tail questions. NQ (Kwiatkowski et al., [2019](https://arxiv.org/html/2410.07176v1#bib.bib16)) and TriviaQA (Joshi et al., [2017](https://arxiv.org/html/2410.07176v1#bib.bib15)) are two widely-studied question-answering (QA) datasets in general domains. BioASQ (Tsatsaronis et al., [2015](https://arxiv.org/html/2410.07176v1#bib.bib26)) is from biomedical domain that has demonstrated significant benefits from RAG when general-purpose LLMs are considered. PopQA (Mallen et al., [2023](https://arxiv.org/html/2410.07176v1#bib.bib20)) focuses on long-tail knowledge and has been shown to be challenging for even advanced LLMs to solve without external knowledge. All these datasets contain questions with short-form answers and most of them list all valid answer variants. This format can support automatic verification of answer appearance in retrieved passages and model responses, leading to more precise evaluations.

Retrieval process. For each question in our benchmark, we query Google Search to retrieve the top 30 results and select the first 10 accessible websites. From each retrieved website, we extract the paragraph corresponding to the snippet provided in Google Search results as the retrieved passage. We do not consider enhancements to the retrieval side, such as query rewriting, as such enhancements are typically already incorporated into commercial information retrieval systems.